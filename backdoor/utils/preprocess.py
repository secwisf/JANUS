import os
import re
from typing import List

from slither.core.cfg.node import NodeType, Node
from slither.core.declarations import FunctionContract
from slither.core.declarations.function import FunctionType
from slither.slithir.operations import InternalCall, EventCall, SolidityCall
from slither.slithir.variables import Constant

from backdoor.state.solidity_info import SolidityInfo
from backdoor.utils.node_utils import is_mapping_type, is_address_type, is_number_type, is_bool_type, is_array_type, \
    is_string_type, is_bytes_type, is_bytes32_type, is_user_defined_type


class SolFile:
    sol_info: SolidityInfo

    def __init__(self):
        self.path = ''
        self.solc = ''
        self.origin_sol = []
        self.new_sol = []

    def set_path(self, path: str, solc='/home/jrj/.solc-select/artifacts/solc-0.6.0/'):
        self.path = path
        self.solc = solc
        self.new_sol = []
        with open(path, 'r', encoding='utf-8') as fr:
            self.origin_sol = fr.read().split('\n')
        try:
            self.sol_info = SolidityInfo(path, solc)
        except:
            raise Exception(f"Slither can not analyse the given file: {path}.")


class PreProcess:
    sol_file: SolFile

    def __init__(self, sol_file: SolFile, max_depth: int = 2):
        self.MAX_DEPTH = max_depth
        self.sol_file = sol_file

    def __call__(self, path="", name_suffix=""):
        return self.pre_process(path, name_suffix)

    def copy_content(self, start: int, end: int, target_sol: List):
        if start < 0 or end < 0 or end < start:
            return
        start_index = start - 1
        end_index = end - 1
        for i in range(start_index, end_index + 1):
            try:
                target_sol.append(self.sol_file.origin_sol[i])
            except:
                print(f'line:{str(i + 1)}')

    def copy_line(self, line: int, target_sol: List):
        if line < 1:
            return
        try:
            target_sol.append(self.sol_file.origin_sol[line - 1])
        except:
            print(f'line:{str(line)}')

    def process_modifiers(self):
        last_line_of_prev_contract = 0
        for contract in self.sol_file.sol_info.get_contracts():
            contract_first_line = contract.source_mapping['lines'][0]
            self.copy_content(last_line_of_prev_contract + 1,
                              contract_first_line - 1, self.sol_file.new_sol)
            last_line_of_prev_contract = contract.source_mapping['lines'][-1]

            function_call_lines = []
            for func in contract.functions_declared:
                if func.function_type not in [FunctionType.CONSTRUCTOR_VARIABLES,
                                              FunctionType.CONSTRUCTOR_CONSTANT_VARIABLES]:
                    function_call_lines += func.source_mapping['lines']

            line = contract_first_line
            while '{' not in self.sol_file.origin_sol[line - 1]:
                self.copy_line(line, self.sol_file.new_sol)
                line += 1
            if '{' in self.sol_file.origin_sol[contract_first_line - 1]:
                self.copy_line(line, self.sol_file.new_sol)
                line += 1

            if line > last_line_of_prev_contract:
                continue

            # state_vars_inherited = contract.state_variables_inherited
            # for svi in state_vars_inherited:
            #     if svi.visibility != 'public':
            #         svi_list = []
            #         self.copy_content(svi.source_mapping['lines'][0], svi.source_mapping['lines'][-1],
            #                           svi_list)
            #         svi_content = "\n".join(svi_list).replace(svi.visibility, 'public')
            #         self.sol_file.new_sol.append(svi_content)
            state_vars_declared = contract.state_variables_declared
            state_vars_declared_lines = []
            for svd in state_vars_declared:
                state_vars_declared_lines += svd.source_mapping['lines']

            self.sol_file.new_sol.append(
                f"event AutoGenerated_mapping_{contract.name}(string mapping_origin, string mapping_cache);")

            for using in contract.using_for:
                for using_for in contract.using_for[using]:
                    using_for_statement = f"using {using_for.type.name} for {str(using)};"
                    self.sol_file.new_sol.append(using_for_statement)

            # func_declared = [func for func in contract.functions_declared if
            #                  func.function_type not in [FunctionType.CONSTRUCTOR_VARIABLES,
            #                                             FunctionType.CONSTRUCTOR_CONSTANT_VARIABLES]]
            # func_declared_names = [func.name for func in func_declared]
            # functions_inherited = [func for func in contract.functions_inherited if
            #                        func.visibility in ['internal',
            #                                            'private'] and func.name not in func_declared_names and not func.is_constructor]

            # for fi in functions_inherited:
            #     first_line_list = []
            #     self.copy_content(fi.source_mapping['lines'][0], fi.entry_point.source_mapping['lines'][0],
            #                       first_line_list)
            #     first_line_content = "\n".join(first_line_list)
            #     inherited_contracts = fi.contract.immediate_inheritance
            #     ic_names = []
            #     for ic in inherited_contracts:
            #         ic_func_names = [f.name for f in ic.functions]
            #         if fi.name in ic_func_names:
            #             ic_names.append(ic.name)
            #     override_content = "override(" if len(ic_names) != 0 else "override "
            #     for ic in ic_names:
            #         override_content += f"{ic},"
            #     if len(ic_names) != 0:
            #         override_content = override_content[:-1]
            #         override_content += ")"
            #     if "override" not in first_line_content:
            #         if "virtual" in first_line_content:
            #             first_line_content = first_line_content.replace("virtual ", f"virtual {override_content} ")
            #         else:
            #             if "returns" in first_line_content:
            #                 first_line_content = first_line_content.replace("returns", f"{override_content} returns")
            #             else:
            #                 first_line_content = first_line_content.replace("{", f"{override_content} {{")
            #
            #     self.sol_file.new_sol.append(first_line_content)
            #     len_lines = len(fi.entry_point.source_mapping['lines'])
            #     if len_lines > 1:
            #         self.copy_content(fi.entry_point.source_mapping['lines'][1],
            #                           fi.entry_point.source_mapping['lines'][-1],
            #                           self.sol_file.new_sol)

            while line <= last_line_of_prev_contract:
                if line not in function_call_lines:
                    if line in state_vars_declared_lines:
                        for svd in state_vars_declared:
                            if line in svd.source_mapping['lines']:
                                svd_list = []
                                self.copy_content(svd.source_mapping['lines'][0], svd.source_mapping['lines'][-1],
                                                  svd_list)
                                svd_content = "\n".join(svd_list)
                                in_derived = False
                                for dc in contract.derived_contracts:
                                    for dc_svd in dc.state_variables_declared:
                                        if svd.name == dc_svd.name:
                                            in_derived = True
                                            break
                                    if in_derived:
                                        break
                                if svd.visibility == 'private' and not in_derived:
                                    svd_content = svd_content.replace(svd.visibility, 'internal')
                                self.sol_file.new_sol.append(svd_content)
                                line = svd.source_mapping['lines'][-1] + 1
                                break
                    else:
                        self.copy_line(line, self.sol_file.new_sol)
                        line += 1
                else:
                    for func in contract.functions_declared:
                        if line in func.source_mapping['lines']:
                            tmp_new_sol = []
                            self.__deal_with_modifier(func, tmp_new_sol)
                            self.sol_file.new_sol += tmp_new_sol
                            line = func.source_mapping['lines'][-1] + 1
                            break

    def __deal_with_modifier(self, func: FunctionContract, tmp_new_sol: List):
        require_before_func = []
        require_after_func = []
        if len(func.nodes) == 0:
            self.copy_content(func.source_mapping['lines'][0], func.source_mapping['lines'][-1], tmp_new_sol)
            return
        if len(func.modifiers) == 0:
            first_line_content = self.__change_declared_func_to_public(func)
            tmp_new_sol.append(first_line_content)
            len_lines = len(func.entry_point.source_mapping['lines'])
            # if func.is_constructor:
            #     constructor_inherited = [f for f in func.contract.functions_inherited if f.is_constructor]
            #     for f in constructor_inherited:
            #         if len(f.entry_point.source_mapping['lines']) <= 1: continue
            #         self.copy_content(f.entry_point.source_mapping['lines'][1],
            #                           f.entry_point.source_mapping['lines'][-2], tmp_new_sol)
            if len_lines > 1:
                self.copy_content(
                    func.entry_point.source_mapping['lines'][1], func.entry_point.source_mapping['lines'][-1],
                    tmp_new_sol)
        else:
            for ir in func.slithir_operations:
                if isinstance(ir, InternalCall) and ir.is_modifier_call:
                    arguments = ir.expression.arguments
                    modifier = ir.function
                    parameters = modifier.parameters
                    parameters_dict = {para.name: '' for para in parameters}

                    # 函数形参与传递参数匹配
                    for index in range(len(arguments)):
                        arg = f'{self.get_expression(arguments[index].source_mapping)}'
                        para = parameters[index]
                        parameters_dict[para.name] = arg

                    met = False
                    place_holder = [
                        node for node in modifier.nodes if node.type == NodeType.PLACEHOLDER]
                    place_holder_lines = []
                    for node in place_holder:
                        place_holder_lines += node.source_mapping['lines']
                    for line in modifier.entry_point.source_mapping['lines'][1:-1]:
                        if line in place_holder_lines:
                            met = True
                            continue
                        line_content = self.sol_file.origin_sol[line - 1]
                        for para in parameters_dict:
                            line_content = re.sub(r'(?<=[^\.:])\b{}\b(?=[^:])'.format(para), parameters_dict[para],
                                                  line_content)
                            line_content = re.sub(r'^\b{}\b(?=[^:])'.format(para), parameters_dict[para], line_content)
                            line_content = re.sub(r'(?<=[^\.:])\b{}\b$'.format(para), parameters_dict[para],
                                                  line_content)
                        if met:
                            require_after_func.append(line_content)
                        else:
                            require_before_func.append(line_content)
            first_line_content = self.__change_declared_func_to_public(func)
            tmp_new_sol.append(first_line_content)
            tmp_new_sol += require_before_func
            # if func.is_constructor:
            #     constructor_inherited = [f for f in func.contract.functions_inherited if f.is_constructor]
            #     for f in constructor_inherited:
            #         self.copy_content(f.entry_point.source_mapping['lines'][1],
            #                           f.entry_point.source_mapping['lines'][-2], tmp_new_sol)
            len_lines = len(func.entry_point.source_mapping['lines'])
            if len_lines > 1:
                self.copy_content(
                    func.entry_point.source_mapping['lines'][1], func.entry_point.source_mapping['lines'][-2],
                    tmp_new_sol)
            tmp_new_sol += require_after_func
            if len_lines > 1:
                self.copy_line(
                    func.entry_point.source_mapping['lines'][-1], tmp_new_sol)

    # 将本合约中声明的函数全部修改为public，便于继承的函数操作
    def __change_declared_func_to_public(self, func):
        first_line_list = []
        self.copy_content(func.source_mapping['lines'][0], func.entry_point.source_mapping['lines'][0],
                          first_line_list)
        first_line_content = "\n".join(first_line_list)
        if func.visibility == 'private':
            first_line_content = first_line_content.replace(func.visibility, 'internal')
        return first_line_content

    def process_internal_call(self, level):
        last_line_of_last_contract = 0
        for contract in self.sol_file.sol_info.get_contracts():
            # 保留两个合约之间的内容
            contract_first_line = contract.source_mapping['lines'][0]
            self.copy_content(last_line_of_last_contract + 1,
                              contract_first_line - 1, self.sol_file.new_sol)
            last_line_of_last_contract = contract.source_mapping['lines'][-1]

            function_call_lines = []
            for func in contract.functions_declared:
                if (func.function_type not in [FunctionType.CONSTRUCTOR_VARIABLES,
                                               FunctionType.CONSTRUCTOR_CONSTANT_VARIABLES]):
                    function_call_lines += func.source_mapping['lines']

            line = contract_first_line
            # if (not contract.is_possible_token) and (contract not in self.sol_file.sol_info.slither.contracts_derived):
            #     self.copy_content(contract_first_line, last_line_of_last_contract, self.sol_file.new_sol)
            #     continue

            while line <= last_line_of_last_contract:
                if line not in function_call_lines:
                    self.copy_line(line, self.sol_file.new_sol)
                    line += 1
                else:
                    line_in_func = False
                    for func in contract.functions_declared:
                        if line in func.source_mapping['lines']:
                            tmp_new_sol = []
                            self.__deal_with_internal_func(func, tmp_new_sol, level)
                            self.sol_file.new_sol += tmp_new_sol
                            line = func.source_mapping['lines'][-1] + 1
                            line_in_func = True
                            break
                    if not line_in_func:
                        self.copy_line(line, self.sol_file.new_sol)
                        line += 1

    def __deal_with_internal_func(self, func, tmp_new_sol: List, level: int):
        internal_calls = []
        if_else_first_branch_list = []
        if_else_only_first_branch_list = []
        else_condition_list = []
        if_else_last_branch_list = []
        self.__initialize_func_config(func, internal_calls, if_else_first_branch_list, else_condition_list,
                                      if_else_last_branch_list, if_else_only_first_branch_list)

        if len(internal_calls) == 0 or len(internal_calls) > 8:
            self.copy_content(
                func.source_mapping['lines'][0], func.source_mapping['lines'][-1], tmp_new_sol)
        else:
            call_visited = {}
            line = func.source_mapping['lines'][0]
            if_else_first_branch_index_list = []

            while line <= func.source_mapping['lines'][-1]:
                line_in_func = False
                line_in_if_else_only_first_line = False if line not in if_else_only_first_branch_list else True
                line_in_if_else_first_line = False if line not in if_else_first_branch_list else True
                line_in_else_condition_line = False if line not in else_condition_list else True
                line_in_if_else_last_branch = False if line not in if_else_last_branch_list else True
                if line_in_if_else_first_line or line_in_if_else_only_first_line:
                    if_else_first_branch_index_list.append(len(tmp_new_sol))
                    tmp_new_sol.append([])

                pre_node_list = []
                node_in = None
                for node in internal_calls:
                    if line in node.source_mapping['lines']:
                        node_in = node
                        irs = node.irs
                        node_content = "".join([self.sol_file.origin_sol[node_line - 1].strip() for node_line in
                                                node.source_mapping['lines']])

                        # 一个node中可能有多个internalCall调用，在ir中有所体现，同时一个node中同一个函数也可能调用多次
                        call_expression_replace_dict = {}
                        for ir_index in range(len(irs)):
                            ir = irs[ir_index]
                            if isinstance(ir, InternalCall) and (
                                    len(ir.function.returns) <= 1) and (not ir.is_modifier_call):
                                line_in_func = True
                                call_return = ir.lvalue if ir.lvalue is not None else None
                                # 函数实参
                                arguments = ir.expression.arguments

                                call_expression_content = self.get_expression(ir.expression.source_mapping)
                                # call_expression是原始的，实际上node_content可能已经修改过了
                                for key in call_expression_replace_dict:
                                    escaped_key = re.escape(key)
                                    call_expression_content = re.sub(r'(?<=[^\.:])\b{}(?=[^:\w])'.format(escaped_key),
                                                                     call_expression_replace_dict[key],
                                                                     call_expression_content)
                                    # 注意“_msgSender()”这种情况
                                    # if re.search(r'\w$', key):
                                    #     call_expression_content = re.sub(
                                    #         r'(?<=[^\.:])\b{}\b(?=[^:])'.format(escaped_key),
                                    #         call_expression_replace_dict[key],
                                    #         call_expression_content)
                                    # else:
                                    #     call_expression_content = re.sub(
                                    #         r'(?<=[^\.:])\b{}\b(?=[^:])'.format(escaped_key),
                                    #         call_expression_replace_dict[key],
                                    #         call_expression_content)
                                call_func_list, local_vars_dict = self.__generate_call_func_code(ir.function, arguments,
                                                                                                 ir.arguments,
                                                                                                 call_visited,
                                                                                                 call_expression_replace_dict,
                                                                                                 call_return, level)
                                if ir.function.canonical_name not in call_visited:
                                    call_visited[ir.function.canonical_name] = 0
                                call_visited[ir.function.canonical_name] += 1
                                pre_node_list += call_func_list

                                if ir.lvalue is None:
                                    # node_content = node_content.replace(call_expression_content, "")
                                    call_expression_replace_dict[call_expression_content] = ""
                                else:
                                    # 返回值是否用到
                                    irs_next = [irs[ir_index_next] for ir_index_next in range(ir_index + 1, len(irs))]
                                    return_used = False
                                    for ir_next in irs_next:
                                        # 返回值被用到，替换成返回值
                                        if ir.lvalue in ir_next.used:
                                            return_used = True
                                            # node_content = node_content.replace(call_expression_content,
                                            #                                     local_vars_dict[ir.lvalue.name])
                                            call_expression_replace_dict[call_expression_content] = local_vars_dict[
                                                ir.lvalue.name]
                                            break
                                    # 返回值没有被用到，按无返回值的情况处理
                                    if not return_used:
                                        # node_content = node_content.replace(call_expression_content, "")
                                        call_expression_replace_dict[call_expression_content] = ""
                        for key in call_expression_replace_dict:
                            node_content = node_content.replace(key, call_expression_replace_dict[key])
                        break

                if not line_in_func:
                    self.copy_line(line, tmp_new_sol)
                    line += 1
                else:
                    if line_in_if_else_first_line or line_in_else_condition_line or line_in_if_else_last_branch or line_in_if_else_only_first_line:
                        last_if_else_first_branch_index = if_else_first_branch_index_list[-1]
                        tmp_new_sol[last_if_else_first_branch_index] += pre_node_list
                    else:
                        tmp_new_sol += pre_node_list
                    # else:
                    #     last_if_else_first_branch_index = if_else_first_branch_index_list[-1]
                    #
                    #     tmp_new_sol[last_if_else_first_branch_index] += pre_node_list
                    # 避免出现一行只有一个分号的情况
                    node_content = re.sub(r"^\s*;", "", node_content)
                    tmp_new_sol.append(node_content)
                    line = node_in.source_mapping['lines'][-1] + 1
                if line_in_if_else_last_branch or line_in_if_else_only_first_line:
                    if_else_first_branch_index_list.pop()

    @staticmethod
    def __initialize_func_config(func, internal_calls, if_else_first_branch_list, else_condition_list,
                                 if_else_last_branch_list, if_else_only_first_branch_list):
        for node in func.nodes:
            call_satisfied = False
            for ir in node.irs:
                # modifier, constructor, event中的call不处理
                if isinstance(ir, InternalCall) and (not ir.is_modifier_call) and (not ir.function.is_constructor) and (
                        not isinstance(ir, EventCall)):
                    call_satisfied = True

            if call_satisfied:
                internal_calls.append(node)
            if node.type == NodeType.IF:
                if_else_only_first_line_judge = False
                if_else_first_line_judge = False
                else_condition_line_judge = False

                if node.son_false is not None:
                    if node.son_false.type == NodeType.IF:
                        if_else_first_line_judge = True
                    elif node.son_false.type == NodeType.ENDIF:
                        if_else_only_first_line_judge = True

                fathers = node.fathers
                for father in fathers:
                    if father.type == NodeType.IF:
                        if father.son_false is not None and father.son_false == node:
                            if_else_first_line_judge = False
                            if_else_only_first_line_judge = False
                            else_condition_line_judge = True
                            break
                if if_else_first_line_judge:
                    if_else_first_branch_list += node.source_mapping['lines']
                elif if_else_only_first_line_judge:
                    if_else_only_first_branch_list += node.source_mapping['lines']
                elif else_condition_line_judge:
                    if (node.son_false is None) or (node.son_false.type == NodeType.ENDIF):
                        if_else_last_branch_list += node.source_mapping['lines']
                    else:
                        else_condition_list += node.source_mapping['lines']

    def __generate_call_func_code(self, func: FunctionContract, arguments, ir_arguments, call_visited_dict,
                                  call_expression_replace_dict, call_return, level: int):
        call_func_list = []
        parameters = func.parameters
        local_vars_dict = {para.name: '' for para in parameters}
        for local_var in func.variables:
            local_vars_dict[local_var.name] = ''

        tmp_func_list = []
        # 函数形参与实参匹配，注意实参可能是表达式
        self.__match_parameters(func, arguments, ir_arguments, parameters, call_visited_dict, local_vars_dict,
                                call_expression_replace_dict, tmp_func_list, level)

        func_return_val = None
        # 处理隐式返回值
        if func.returns is not None and len(func.returns) != 0:
            func_return_val = func.returns[0]
        if func_return_val is not None:
            self.__deal_with_implicit_return_value(func, func_return_val, call_return, local_vars_dict,
                                                   call_visited_dict,
                                                   tmp_func_list, level)

        # 统计所有局部变量，并进行名称替换
        local_vars = list(set(func.variables).difference(set(func.parameters)).difference(set(func.returns)))
        for var in local_vars:
            origin_var_name = var.name
            func_special_name = f"{func.contract.name}_{func.name}_{str(len(func.parameters))}"
            new_var_name = f"{func_special_name}_{origin_var_name}_{str(call_visited_dict.get(func.canonical_name, 0))}_{str(level)}"
            local_vars_dict[origin_var_name] = new_var_name

        try:
            if len(func.entry_point.source_mapping['lines']) > 1:
                # 函数没有返回值，直接替换
                if func_return_val is None:
                    call_func_list.append('{')
                    call_func_list += tmp_func_list
                    self.__deal_with_no_return(func, local_vars_dict, call_func_list)
                    call_func_list.append('}')
                # 有返回值，将return 语句全部替换成 'return_var ='
                # 需要注意，可能会有多个return语句，通过不同bool 变量标记，并将返回语句用if包含
                # 注意与__deal_with_implicit_return中对应
                else:
                    visited_time = call_visited_dict.get(func.canonical_name, 0)
                    var_name = f'{func.contract.name}_{func.name}_{call_return.name}_{str(visited_time)}_{str(level)}'
                    local_vars_dict[call_return.name] = var_name
                    if is_mapping_type(call_return.type) or is_array_type(call_return.type) or is_user_defined_type(
                            call_return.type):
                        initiate_return_value_code = f'{str(call_return.type)} storage {var_name};'
                    elif is_address_type(call_return.type) or is_number_type(call_return.type) or is_bool_type(
                            call_return.type) or is_bytes32_type(call_return.type):
                        initiate_return_value_code = f'{str(call_return.type)} {var_name};'
                    else:
                        initiate_return_value_code = f'{str(call_return.type)} memory {var_name};'
                    call_func_list.append(initiate_return_value_code)
                    call_func_list.append('{')
                    call_func_list += tmp_func_list
                    call_func_list.append('{')
                    self.__deal_with_returns(func, call_return, local_vars_dict, call_func_list, visited_time, level)
                    call_func_list.append('}')
                    call_func_list.append('}')
        except:
            call_func_list = []
            local_vars_dict = {}
        return call_func_list, local_vars_dict

    def __deal_with_no_return(self, func: FunctionContract, local_vars_dict: dict, call_func_list: list):
        line = func.entry_point.source_mapping['lines'][1]
        while line < func.entry_point.source_mapping['lines'][-1]:
            line_content = self.sol_file.origin_sol[line - 1]
            for var in local_vars_dict:
                line_content = re.sub(r'(?<=[^\.:])\b{}\b(?=[^:])'.format(var), local_vars_dict[var], line_content)
                line_content = re.sub(r'^\b{}\b(?=[^:])'.format(var), local_vars_dict[var], line_content)
                line_content = re.sub(r'(?<=[^\.:])\b{}\b$'.format(var), local_vars_dict[var], line_content)
            # 无返回值的情况
            line_content = re.sub(r'\breturn\b', "revert()", line_content)
            line_content = re.sub(r"^\s*;", "", line_content)
            call_func_list.append(line_content)
            line += 1

    def __deal_with_returns(self, func: FunctionContract, call_return, local_vars_dict: dict,
                            call_func_list: list, visited_time: int, level: int):
        return_nodes = [node for node in func.nodes if node.type == NodeType.RETURN]
        return_num = len(return_nodes)
        left_bracket = 0
        if return_num > 1:
            # 进一步避免stack too deep error
            for i in range(len(return_nodes) - 1):
                return_judge_statement = f'bool {self.get_return_judge_var_name(call_return, i, visited_time, level)} = false;'
                call_func_list.append(return_judge_statement)

            call_func_list.append('{')
            left_bracket += 1
            # 应对多个return的问题，需要暂存修改的状态变量
            for state_var in func.state_variables_written:
                if is_mapping_type(state_var.type) or is_array_type(state_var.type) or is_user_defined_type(
                        state_var.type):
                    initiate_cache_var_statement = f"{str(state_var.type)} storage cache_{state_var.name}_{str(visited_time)}_{str(level)} = {state_var.name};"
                elif is_address_type(state_var.type) or is_number_type(state_var.type) or is_bool_type(
                        state_var.type) or is_bytes32_type(state_var.type):
                    initiate_cache_var_statement = f"{str(state_var.type)} cache_{state_var.name}_{str(visited_time)}_{str(level)};"
                else:
                    initiate_cache_var_statement = f"{str(state_var.type)} memory cache_{state_var.name}_{str(visited_time)}_{str(level)} = {state_var.name};"
                call_func_list.append(initiate_cache_var_statement)
        line = func.entry_point.source_mapping['lines'][1]
        while line < func.entry_point.source_mapping['lines'][-1]:
            line_content = self.sol_file.origin_sol[line - 1]
            for var in local_vars_dict:
                line_content = re.sub(r'(?<=[^\.:])\b{}\b(?=[^:])'.format(var), local_vars_dict[var], line_content)
                line_content = re.sub(r'^\b{}\b(?=[^:])'.format(var), local_vars_dict[var], line_content)
                line_content = re.sub(r'(?<=[^\.:])\b{}\b$'.format(var), local_vars_dict[var], line_content)
            line_content = re.sub(r'\breturn\b', f'{local_vars_dict[call_return.name]} =', line_content)
            line_content = re.sub(r"^\s*;", "", line_content)
            if return_num > 1:
                line_in_return = False
                for i in range(return_num):
                    node = return_nodes[i]
                    if line in node.source_mapping['lines']:
                        if i == 0:
                            call_func_list.append(
                                f'{self.get_return_judge_var_name(call_return, i, visited_time, level)} = true;')
                            call_func_list.append(line_content)
                            for state_var in func.state_variables_written:
                                cache_statement = f"cache_{state_var.name}_{str(visited_time)}_{str(level)} = {state_var.name};"
                                call_func_list.append(cache_statement)
                        elif 0 < i < (return_num - 1):
                            condition = ''
                            for j in range(0, i):
                                condition += f'(!{self.get_return_judge_var_name(call_return, j, visited_time, level)}) && '
                            call_func_list.append(f"if ({condition[:-4]}) {{")
                            call_func_list.append(
                                f'{self.get_return_judge_var_name(call_return, i, visited_time, level)} = true;')
                            call_func_list.append(line_content)
                            for state_var in func.state_variables_written:
                                cache_statement = f"cache_{state_var.name}_{str(visited_time)}_{str(level)} = {state_var.name};"
                                call_func_list.append(cache_statement)
                            call_func_list.append("}")
                            if len(func.state_variables_written) > 0:
                                call_func_list.append(f"else {{")
                                for state_var in func.state_variables_written:
                                    if is_mapping_type(state_var.type):
                                        cache_statement = f'emit AutoGenerated_mapping_{func.contract.name}("{state_var.name}", "cache_{state_var.name}_{str(visited_time)}_{str(level)}");'
                                    else:
                                        cache_statement = f"{state_var.name} = cache_{state_var.name}_{str(visited_time)}_{str(level)};"
                                    call_func_list.append(
                                        cache_statement)
                                call_func_list.append("}")
                        elif i == (return_num - 1):
                            condition = ''
                            for j in range(0, i):
                                condition += f"(!{self.get_return_judge_var_name(call_return, j, visited_time, level)}) && "
                            call_func_list.append(f"if ({condition[:-4]}) {{")
                            call_func_list.append(line_content)
                            call_func_list.append("}")
                            if len(func.state_variables_written) > 0:
                                call_func_list.append(f"else {{")
                                for state_var in func.state_variables_written:
                                    if is_mapping_type(state_var.type):
                                        cache_statement = f'emit AutoGenerated_mapping_{func.contract.name}("{state_var.name}", "cache_{state_var.name}_{str(visited_time)}_{str(level)}");'
                                    else:
                                        cache_statement = f"{state_var.name} = cache_{state_var.name}_{str(visited_time)}_{str(level)};"
                                    call_func_list.append(cache_statement)
                                call_func_list.append("}")
                        line_in_return = True
                        line = node.source_mapping['lines'][-1] + 1
                        break
                if not line_in_return:
                    call_func_list.append(line_content)
                    line += 1
            else:
                call_func_list.append(line_content)
                line += 1

        if return_num > 1:
            for i in range(left_bracket):
                call_func_list.append('}')

    def __match_parameters(self, func, arguments, ir_arguments, parameters, call_visited_dict, local_vars_dict,
                           call_expression_replace_dict, call_func_list, level):
        for index in range(len(arguments)):
            arg = f'{self.get_expression(arguments[index].source_mapping)}'
            for key in call_expression_replace_dict:
                arg = arg.replace(key, call_expression_replace_dict[key])
            if arg == ir_arguments[index].name:
                para = parameters[index]
                local_vars_dict[para.name] = arg
            else:
                if isinstance(ir_arguments[index], Constant):
                    if is_string_type(ir_arguments[index].type):
                        ir_index_name = f'"{ir_arguments[index].original_value}"'
                    else:
                        ir_index_name = ir_arguments[index].original_value
                else:
                    if func.canonical_name not in call_visited_dict:
                        if is_string_type(ir_arguments[index].type):
                            string_name = ir_arguments[index].name.replace(" ", "")
                            ir_index_name = f'{string_name}_0_{str(level)}'
                        else:
                            ir_index_name = f'{ir_arguments[index].name}_0_{str(level)}'
                    else:
                        if is_string_type(ir_arguments[index].type):
                            string_name = ir_arguments[index].name.replace(" ", "")
                            ir_index_name = f'{string_name}_{str(call_visited_dict[func.canonical_name])}_{str(level)}'
                        else:
                            ir_index_name = f'{ir_arguments[index].name}_{str(call_visited_dict[func.canonical_name])}_{str(level)}'
                    if is_number_type(ir_arguments[index].type) or is_bool_type(
                            ir_arguments[index].type) or is_address_type(ir_arguments[index].type) or is_bytes32_type(
                        ir_arguments[index].type):
                        init_argument_statement = f'{str(ir_arguments[index].type)} {ir_index_name} = {arg};'
                    elif is_array_type(ir_arguments[index].type) or is_mapping_type(
                            ir_arguments[index].type) or is_user_defined_type(ir_arguments[index].type):
                        init_argument_statement = f'{str(ir_arguments[index].type)} storage {ir_index_name} = {arg};'
                    else:
                        init_argument_statement = f'{str(ir_arguments[index].type)} memory {ir_index_name} = {arg};'
                    call_func_list.append(init_argument_statement)
                para = parameters[index]
                local_vars_dict[para.name] = ir_index_name

    @staticmethod
    def __deal_with_implicit_return_value(func, func_return_val, call_return, local_vars_dict, call_visited_dict,
                                          call_func_list, level):
        # 无返回值或返回值未被用到的情况。为避免使用了返回变量，需要声明返回变量，同时注意调用次数和目前层次
        if func_return_val.name != "":
            if call_return is None:
                string_name = func_return_val.name.replace(" ", "")
                return_value_name = f'{func.contract.name}_{func.name}_{str(len(func.parameters))}_{string_name}_{str(call_visited_dict.get(func.canonical_name, 0))}_{str(level)}'
                init_return_var_statement = f'{str(func_return_val.type)} {return_value_name}'
                call_func_list.append(init_return_var_statement)
                local_vars_dict[func_return_val.name] = return_value_name
            else:
                local_vars_dict[
                    func_return_val.name] = f'{func.contract.name}_{func.name}_{call_return.name}_{str(call_visited_dict.get(func.canonical_name, 0))}_{str(level)}'

    @staticmethod
    def get_return_judge_var_name(call_return, index: int, visited_time: int, level: int) -> str:
        return f"{call_return.name}_{str(index)}_{str(visited_time)}_{str(level)}"

    def process_conditions(self):
        last_line_of_last_contract = 0
        for contract in self.sol_file.sol_info.get_contracts():
            contract_first_line = contract.source_mapping['lines'][0]
            self.copy_content(last_line_of_last_contract + 1,
                              contract_first_line - 1, self.sol_file.new_sol)
            last_line_of_last_contract = contract.source_mapping['lines'][-1]

            condition_lines = {}
            require_lines = {}
            assert_lines = {}
            funcs = [f for f in contract.functions_and_modifiers_declared if
                     f.function_type not in [FunctionType.CONSTRUCTOR_VARIABLES,
                                             FunctionType.CONSTRUCTOR_CONSTANT_VARIABLES]]
            for func in funcs:
                for node in func.nodes:
                    if node.type == NodeType.IF:
                        for line in node.source_mapping['lines']:
                            condition_lines[line] = node
                        continue
                    for ir in node.irs:
                        if isinstance(ir, SolidityCall):
                            name = ir.function.name
                            if name.startswith('require'):
                                for line in node.source_mapping['lines']:
                                    require_lines[line] = node
                            elif name.startswith('assert'):
                                for line in node.source_mapping['lines']:
                                    assert_lines[line] = node

            line = contract_first_line
            while line <= last_line_of_last_contract:
                if line in condition_lines:
                    node_content = "".join([self.sol_file.origin_sol[node_line - 1].strip() for node_line in
                                            condition_lines[line].source_mapping['lines']])

                    if '{' not in node_content and ('?' not in node_content and ':' not in node_content):
                        condition_expression = self.get_expression(condition_lines[line].source_mapping)
                        node_content = node_content.replace(f"{condition_expression})", f"{condition_expression}) {{")
                        node_content = f"{node_content} }}"
                        self.sol_file.new_sol.append(node_content)
                    elif '?' in node_content and ':' in node_content:
                        condition_expression = self.get_expression(condition_lines[line].expression.source_mapping)
                        son_true_expression = condition_lines[line].son_true
                        son_false_expression = condition_lines[line].son_false
                        ternary_operator_begin_index = node_content.find(condition_expression)
                        ternary_operator_end_index = node_content.rfind(";")
                        ternary_operation = node_content[ternary_operator_begin_index:ternary_operator_end_index + 1]
                        node_content = node_content.replace(ternary_operation, "")
                        do_true_statement = f"{node_content} {self.get_expression(son_true_expression.expression.source_mapping)};"
                        do_false_statement = f"{node_content} {self.get_expression(son_false_expression.expression.source_mapping)};"
                        new_node_content = f'''
                        if ({condition_expression}) {{
                            {do_true_statement}
                        }} else {{
                            {do_false_statement}
                        }}
                        '''
                        self.sol_file.new_sol.append(new_node_content)
                    else:
                        self.sol_file.new_sol.append(node_content)
                    line = condition_lines[line].source_mapping['lines'][-1] + 1
                elif line in require_lines:
                    condition_expression = self.get_expression(
                        require_lines[line].expression.arguments[0].source_mapping)
                    new_content = f"if (!({condition_expression})) {{\nrevert();\n}}"
                    self.sol_file.new_sol.append(new_content)
                    line = require_lines[line].source_mapping['lines'][-1] + 1
                elif line in assert_lines:
                    condition_expression = self.get_expression(
                        assert_lines[line].expression.arguments[0].source_mapping)
                    new_content = f"if (!({condition_expression})) {{\nrevert();\n}}"
                    self.sol_file.new_sol.append(new_content)
                    line = assert_lines[line].source_mapping['lines'][-1] + 1
                else:
                    self.copy_line(line, self.sol_file.new_sol)
                    line += 1

    def write_new_file(self, path="", name_suffix=""):
        old_filename = os.path.basename(self.sol_file.path)[:-4]
        new_filename = old_filename + name_suffix + '.sol'
        if path == "":
            path = os.path.dirname(self.sol_file.path)
        else:
            if not os.path.exists(path):
                os.makedirs(path)
        new_path = os.path.join(path, new_filename)
        with open(new_path, 'w') as fw:
            for line in self.sol_file.new_sol:
                if isinstance(line, List):
                    for line_in in line:
                        fw.write(f"{line_in}\n")
                elif isinstance(line, str):
                    fw.write(f"{line}\n")
        return new_path

    def pre_process(self, path, name_suffix='_inline'):
        try:
            os.system(f'npx prettier --write "{self.sol_file.path}"')
            self.process_conditions()
            new_path = self.write_new_file(path=path, name_suffix=name_suffix)
            os.system(f'npx prettier --write "{new_path}"')
            self.sol_file.set_path(new_path, self.sol_file.solc)
        except Exception as e:
            print("Error in processing conditions")
            os.remove(new_path)
            raise e
        try:
            self.process_modifiers()
            new_path = self.write_new_file()
            os.system(f'npx prettier --write "{new_path}"')
            self.sol_file.set_path(new_path, self.sol_file.solc)
        except Exception as e:
            print("Error in processing modifiers")
            os.remove(new_path)
            raise e

        for i in range(self.MAX_DEPTH):
            try:
                self.process_internal_call(i)
                new_path = self.write_new_file()
                os.system(f'npx prettier --write "{new_path}"')
                self.sol_file.set_path(new_path, self.sol_file.solc)
            except Exception as e:
                print(f"Error in processing internal calls _ {str(i + 1)}")
                os.remove(new_path)
                raise e
        try:
            self.sol_file.set_path(new_path, self.sol_file.solc)
        except Exception as e:
            print()
            os.remove(new_path)
            raise e
        return new_path

    def get_expression(self, source_mapping: dict) -> str:
        line_first = source_mapping['lines'][0]
        line_last = source_mapping['lines'][-1]
        if line_first == line_last:
            expression_content = self.sol_file.origin_sol[line_first - 1][source_mapping['starting_column'] - 1:
                                                                          source_mapping['ending_column'] - 1].strip()
        else:
            expression_content = self.sol_file.origin_sol[line_first - 1][
                                 source_mapping['starting_column'] - 1:].strip()
            for i in range(line_first + 1, line_last):
                expression_content += self.sol_file.origin_sol[i - 1].strip()
            expression_content += self.sol_file.origin_sol[line_last -
                                                           1][:source_mapping['ending_column'] - 1].strip()
        return expression_content


def del_comments_and_blank(path):
    with open(path, 'r') as fr:
        content = fr.read()
    content_new = re.sub(r'/\*.*?\*/', '', content, flags=re.S)
    content_new = re.sub(r'(//.*)', '', content_new)
    content_new_list = content_new.split("\n")
    new_content_list = [f"{line}\n" for line in content_new_list if line != ""]
    with open(path, 'w') as fw:
        for line in new_content_list:
            fw.write(line)
